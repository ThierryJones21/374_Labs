\documentclass{article}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\lstset{
    language=Verilog,
    % wrap text
    breaklines=true, 
    % line numbers
    numbers=left,
    numberstyle=\tiny\color{black},
    numbersep=10pt,
    % other styling
    basicstyle=\small\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    tabsize=2
}
\graphicspath{ {images/} }

\title{
    \begin{large}
        ELEC374 - Lab 2
    \end{large}
}
\author{Naod Dereje - 20103501, Thierry Jones - 20108349, Jamie Won - 20113217}

\begin{document}
\maketitle
\cleardoublepage
\tableofcontents
\cleardoublepage

Each instruction used to demonstrate the circuitry requires a specific OP Code. The following table shows the OP Code values stored in RAM initially, their address in RAM and also the instruction itself. For a full version of the initial RAM state, please see Appendix \ref{ram_init}.
\begin{figure}[h!] \label{relevant_ram_init}
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            Address & Instruction & Op code (hex) \\
            \hline
            1 & st \$90, R1 & 10080090 \\
            \hline
            2 & st \$90(R1), R1 & 10080090 \\
            \hline
            3 & addi R2, R1, \$-5 & 590FFFFB \\
            \hline
            4 & andi R2, R1, \$26 & 61080026 \\
            \hline
            5 & ori R2, R1, \$26 & 69080026 \\
            \hline
        \end{tabular}
        \caption{Table of relevant values in RAM initially}
    \end{center}
\end{figure}

\section{THIERRY PLEASE MOVE AND RENAME THIS sections 3b and 3c - should probably rename this or putit under circuitry demonstration }
    
    \subsection{Store Instructions}
        Two store instructions were used to test the RAM and memory interface logic. The instruction sequence for \emph{st \$90, R1} and \emph{st \$90(R1), R1} can be found in Appendix \ref{st_case_1_sequence} and Appendix \ref{st_case_2_sequence} respectively.
        
        \subsubsection{st \$90, R1}
            This instruction is similar to the load immediate instruction. It is however, in a sense, reversed. Where the load ends by reading from the Z\_LO register and its contents to the specified register, this instruction finishes by reading from the MDR and writing to the RAM.
        \subsubsection{st \$90(R1), R1}
            This instruction is similar to the load instruction. It is however, in a sense, reversed. While both instructions end by reading from the MDR register, the load instruction writes its contents to the specified register, while the store instruction writes to the RAM.

    \subsection{ALU Immediate Instructions}
        The ALU immediate instruction functionality was simulating using the \emph{addi R2, R1, -5}, \emph{andi R2, R1, \$26} and \emph{ori R2, R1, \$26} instructions. The instruction sequences can be found in Appendix \ref{addi_sequence}, Appendix \ref{andi_sequence} and Appendix \ref{ori_sequence} respectively. The instructions sequences for these sections differ only in the control signal used for the ALU and the preloaded instruction in RAM. The specific opcodes for these instructions can be found in \ref{relevant_ram_init}. Otherwise, the sequences follow the guidelines given in the spec document exactly.

\section{Components}
    The purpose of this lab was to design, simulate, implement and verify a simple RISC computer(Mini SRC), including the circuits associated with the logic behind: 
    Select and Encode, Memory Subsystem, CON FF and Input/Output ports. Verilog was chosen over VHDL as it is better for more complex simulations. The verilog code 
    for each of these components can be found in the Appendices.
    
    \subsection{Select and Encode}


    \subsection{Memory Subsystem}
    

    \subsection{CON FF}
    

    \subsection{Input/Output Ports}
    
\section{Circuitry Demonstration}
    To demonstrate the success of the RAM and memory interface logic, multiple testbenches were created to simulate each operation. 
    The testbenches all have their own control sequences unique to every operation and can be found in the appendices. The following subsections 
    of the cicuitry demonstration will detail the changes made in the test benches due to the control sequence changing as well as the waveforms generated by each simulation.

\appendix
\section{Select and Encode}
\section{Memory Subsystem}
\section{CON FF}
\section{Input/Output Ports}
The input and output ports in the datapath allow for the bus to receive values from an input unit, as well as output values from the bus onto the output unit. In a real implmentation of an I/O port instruction, the logic for these ports would be used to read from some input given to port, and give feedback to the system through some output such as updated the result of an arithmetic instruction, or the bit pattern after a bit shift or rotation was completed.
\section{Control Sequences}
    \subsection{st \$90, R1} \label{st_case_1_sequence}
    \subsection{st \$90(R1), R1} \label{st_case_2_sequence}
    \subsection{addi R2, R1, -5} \label{addi_sequence}
    \subsection{andi R2, R1 \$26} \label{andi_sequence}
    \subsection{ori R2, R1 \$26} \label{ori_sequence}
\section{RAM - Initial Contents} \label{ram_init}

\end{document}
