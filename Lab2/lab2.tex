\documentclass{article}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\lstset{
    language=Verilog,
    % wrap text
    breaklines=true, 
    % line numbers
    numbers=left,
    numberstyle=\tiny\color{black},
    numbersep=10pt,
    % other styling
    basicstyle=\small\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    tabsize=2
}
\graphicspath{ {Images/} }

\title{
    \begin{large}
        ELEC374 - Lab 2
    \end{large}
}
\author{Naod Dereje - 20103501, Thierry Jones - 20108349, Jamie Won - 20113217}

\begin{document}
\maketitle
\cleardoublepage
\tableofcontents
\cleardoublepage


\section{Components}
    The purpose of this lab was to design, simulate, implement and verify a simple RISC computer(Mini SRC), including the circuits associated with the logic behind: 
    Select and Encode, Memory Subsystem, CON FF and Input/Output ports. Verilog was chosen over VHDL as it is better for more complex simulations. The verilog code 
    for each of these components can be found in the Appendices.
    
    \subsection{Select and Encode}
    Select and Encode logic was used for load and store instruction as well as add, and, or instructions. The opcode that is read into Select and Encode is used to create the outputs for Ra, Rb , and Rc, in order to generate the GRa, GRb, GRc, which is the encoded to R0in-R15in and R0out-R15out registers. Their is also support for a sign-extended C value in the lower 19 bits of the instrcution address.

    \subsection{Memory Subsystem}
    The memory subsystem was created using the Megafunction in Quartus to generate inputs and outputs for the RAM accordingly. In order to define the memory subsystem within our project, an instance of the RAM was created on our datapath, and was wired to the datapath using existing wires created in the previous lab. The RAM's memory is accessed through the corresponding hex file in the project, Which contains the opcodes for the instructions at the specififed memory slots. A detialed breakdown of the memory subsystem can be found at \ref{ram.v}.

    \subsection{CON FF}
    The conff logic is created to ensure that conidtional logic such as the branch insturction are able to be executed. The instructions assocaited with the conditional logic are stored in I-formatting, with the second register holding the branching condition. The components for the con ff logic can be found at Appendix \ref{con_ff.v}.

    \subsection{Input/Output Ports}
    The input and output ports in the datapath allow for the bus to receive values from an input unit, as well as output values from the bus onto the output unit. In a real implmentation of an I/O port instruction, the logic for these ports would be used to read from some input given to port, and give feedback to the system through some output such as updating the result of an arithmetic instruction, or the bit pattern after a bit shift or rotation was completed.

\section{Circuitry Demonstration}
    To demonstrate the success of the RAM and memory interface logic, multiple testbenches were created to simulate each operation. 
    The testbenches all have their own control sequences unique to every operation and can be found in the appendices. The following subsections 
    of the cicuitry demonstration will detail the changes made in the test benches due to the control sequence changing as well as the waveforms generated by each simulation.
    Each instruction used to demonstrate the circuitry requires a specific OP Code. The following table shows the OP Code values stored in RAM initially, their address in RAM and also the instruction itself. For a full version of the initial RAM state, please see Appendix \ref{ram_init}.
    \begin{figure}[h!] \label{relevant_ram_init}
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                Address (hex) & Instruction & Op code (hex) \\
                \hline
                ? & ld R1, 85 & 00800085 \\
                \hline
                ? & ld R1, \$35(R0) & 00800023 \\
                \hline
                ? & ldi R1,\$85 & 08800085 \\
                \hline
                ? & ldi R1, \$35(R0) & 08800023 \\
                \hline
                1* & st \$90, R1 & 10080090 \\ % Thierry, Naod, don't change this line, see below figure for rationale
                \hline
                1* & st \$90(R1), R1 & 10080090 \\ % Thierry, Naod, don't change this line, see below figure for rationale
                \hline
                ? & addi R2, R1, \$-5 & 590FFFFB \\
                \hline
                ? & andi R2, R1, \$26 & 61080026 \\
                \hline
                ? & ori R2, R1, \$26 & 69080026 \\
                \hline
                ? & in R1  & 00000151 \\
                \hline
                ? & out R1  & 00000161 \\
                \hline
                20 & brzr R2, 35 & 91000023 \\
                \hline
                21 & brnz R2, 35 & 91200023 \\
                \hline
                22 & brpl R2, 35 & 91400023 \\
                \hline
                23 & brmi R2, 35 & 91600023 \\
                \hline
                18 & jal R1 & A0800000 \\ % Thierry, Naod, don't change this line, these are the jump instructions - we don't want to generate new waveforms
                \hline
                19 & jr R1 & 98800000 \\ % Thierry, Naod, don't change this line, these are the jump instructions - we don't want to generate new waveforms
                \hline
            \end{tabular}
            \caption{Table of relevant values in RAM initially}
        \end{center}
    \end{figure}
    \\
    \small{*Note that these instructions were tested before the rest, thus, the .hex file hadn't be completed. Thus, Appendix \ref{ram_st_case_1} and Appendix \ref{ram_st_case_2} have empty values in RAM where the OP Codes are for later tests.}

    \subsection{Load Instructions}
        Two load instructions were tested to ensure that the values are able to load from the RAM onto its appropriate register. The control sequences for \emph{ld R1,\$85}, \emph{ld R0, \$35(R1)}, \emph{ldi R1,\$85}, \emph{ldi R0, \$35(R1)} can be found in  Appendices \ref{ld_case_1_sequence}, \ref{ld_case_2_sequence}, \ref{ldi_case_3_sequence}, and \ref{ld_case_4_sequence}  respectively. The value $85_{16}$ was preloaded into the memory initialization file in slot 85 for these instructions. The specific opcodes for these instructions can be found in Figure \ref{relevant_ram_init}. 
       
        \begin{figure}[h!]

            \begin{center}
                \includegraphics[width=15cm]{ld_case_1_wave_top_half.png}
                \caption{1st screenshot of the simulated waveforms for the  ld  R1, \$90 instruction}
            \end{center}
        \end{figure}

        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{ld_case_1_wave_bottom_half.png}
                \caption{2nd screenshot of the simulated waveforms for the and ld  R1, \$90 instruction}
            \end{center}
        \end{figure}

        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{ld_case_2_wave_top_half.png}
                \caption{1st screenshot of the simulated waveforms for the  ld R0, \$35(R1) instruction}
            \end{center}
        \end{figure}

        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{ld_case_2_wave_bottom_half.png}
                \caption{2nd screenshot of the simulated waveforms for the and ld R0, \$35(R1) instruction}
            \end{center}
        \end{figure}

        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{ldi_case_3_wave_top_half.png}
                \caption{1st screenshot of the simulated waveforms for the  ldi  R1, \$90 instruction}
            \end{center}
        \end{figure}

        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{ldi_case_3_wave_bottom_half.png}
                \caption{2nd screenshot of the simulated waveforms for the ldi  R1, \$90 instruction}
            \end{center}
        \end{figure}

        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{ldi_case_4_wave_top_half.png}
                \caption{1st screenshot of the simulated waveforms for the  ldi R0, \$35(R1) instruction}
            \end{center}
        \end{figure}
        
        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{ldi_case_4_wave_bottom_half.png}
                \caption{2nd screenshot of the simulated waveforms for the ldi R0, \$35(R1) instruction}
            \end{center}
        \end{figure}
        


    \subsection{Store Instructions}
        Two store instructions were used to test the RAM and memory interface logic. The instruction sequence for \emph{st \$90, R1} and \emph{st \$90(R1), R1} can be found in Appendix \ref{st_case_1_sequence} and Appendix \ref{st_case_2_sequence} respectively. It should be noted that the value $85_{16}$ was preloaded into R1 for both instructions. The specific opcodes for these instructions can be found in Figure \ref{relevant_ram_init}. 
        
        \subsubsection{st \$90, R1}
            This instruction is similar to the load immediate instruction. It is however, in a sense, reversed. Where the load ends by reading from the Z\_LO register and its contents to the specified register, this instruction finishes by reading from the MDR and writing to the RAM. The results of this instruction, in RAM, can be found in Appendix \ref{ram_st_case_1} at address $90_{16}$ (line 22). The following image shows the waveform generated by running this sequence. 

            \begin{figure}[h!]
                \begin{center}
                    \includegraphics[width=15cm]{st_case_1_wave.png}
                    \caption{A screenshot of the simulated waveforms for the and st \$90, R1 instruction}
                \end{center}
            \end{figure}

        \subsubsection{st \$90(R1), R1}
            This instruction is similar to the load instruction. It is however, in a sense, reversed. While both instructions end by reading from the MDR register, the load instruction writes its contents to the specified register, while the store instruction writes to the RAM. The results of this instruction, in RAM, can be found in Appendix \ref{ram_st_case_2} at address $115_{16}$ (line 38).The following image shows the waveform generated by running this sequence. 

            \begin{figure}[h!]
                \begin{center}
                    \includegraphics[width=15cm]{st_case_1_wave.png}
                    \caption{A screenshot of the simulated waveforms for the and st \$90(R1), R1 instruction}
                \end{center}
            \end{figure}
            

    \subsection{ALU Immediate Instructions}
        The ALU immediate instruction functionality was simulating using the \emph{addi R2, R1, -5}, \emph{andi R2, R1, \$26} and \emph{ori R2, R1, \$26} instructions. The instruction sequences can be found in Appendix \ref{addi_sequence}, Appendix \ref{andi_sequence} and Appendix \ref{ori_sequence} respectively. The instructions sequences for these sections differ only in the control signal used for the ALU and the preloaded instruction in RAM. The specific opcodes for these instructions can be found in Figure \ref{relevant_ram_init}. Otherwise, the sequences follow the guidelines given in the spec document exactly.

    \subsection{Branch Instructions}
        Four branch instructions were used to test the RAM and \emph{con_ff} module. The instruction sequences \emph{brzr R2, 35}, \emph{brnz R2, 35}, \emph{brpl R2, 35} and \emph{brmi R2, 35} can be found in Appendix \ref{brzr_sequence}, \ref{brnz_sequence}, \ref{brpl_sequence} and \ref{brmi_sequence} respectively. The specific opcodes for these instructions can be found in Figure \ref{relevant_ram_init}. The value of R2 will be preloaded with the decimal value 1 for each of the simulated waveforms. 

        \subsubsection{brzr R2, 35}
            Since the value $1_{10}$ was preloaded into R2, and $1 \neq 0$ it is expected that the PC does not jump in T6, or when the Present\_State signal is equal to 7. This is reflected in the image below.

                \begin{figure}[h!]
                    \begin{center}
                        \includegraphics[width=15cm]{brzr_wave.png}
                        \caption{A screenshot of the simulated waveforms for brzr, brzr R2, 35}
                    \end{center}
                \end{figure}

        \subsubsection{brnz R2, 35}
            Since the value $1_{10}$ was preloaded into R2, and $1 \neq 0$ it is expected that the PC jumps in T6, or when the Present\_State signal is equal to 7. This is reflected in the image below. It should be noted that $21_{16} + 1_{10} + 35_{10} = 45_{16}$. 

                \begin{figure}[h!]
                    \begin{center}
                        \includegraphics[width=15cm]{brnz_wave.png}
                        \caption{A screenshot of the simulated waveforms for brnz, brnz R2, 35}
                    \end{center}
                \end{figure}

        \subsubsection{brpl R2, 35}
            Since the value $1_{10}$ was preloaded into R2, and $1 > 0$ it is expected that the PC jumps in T6, or when the Present\_State signal is equal to 7. This is reflected in the image below. It should be noted that $22_{16} + 1_{10} + 35_{10} = 46_{16}$. 
        
                \begin{figure}[h!]
                    \begin{center}
                        \includegraphics[width=15cm]{brpl_wave.png}
                        \caption{A screenshot of the simulated waveforms for brpl, brpl R2, 35}
                    \end{center}
                \end{figure}

        \subsubsection{brmi R2, 35}
            Since the value $1_{10}$ was preloaded into R2, and $1 > 0$ it is expected that the PC does not jump in T6, or when the Present\_State signal is equal to 7. This is reflected in the image below.
        
                \begin{figure}[h!]
                    \begin{center}
                        \includegraphics[width=15cm]{brmi_wave.png}
                        \caption{A screenshot of the simulated waveforms for brmi, brmi R2, 35}
                    \end{center}
                \end{figure}

    \subsection{Special Instructions}
    The special instructions functionality was simulated using the \emph{mfhi R2} and \emph{mflo R2} commands. For the most part, they were identical to the template provided for the ALU immediate instructions. The difference lay in T3, where instead of \emph{Rout} being enabled, \emph{Rin} was and the \emph{highout} and \emph{lowout} signals were enabled for the \emph{mfhi R2} and \emph{mflo R2} commands respectively. 
    
        \subsubsection{mfhi R2}
            The HI register was preloaded to have a value of 100. As seen in T3, or when the signal Present\_state is equal to 4, the value stored in R2 is set to the value in HI. It should be noted that $100_{10}$ is equivalent to $64_{16}$. The control sequence for this instruction can be found in Appendix \ref{mfhi_sequence}.

                \begin{figure}[h!]
                    \begin{center}
                        \includegraphics[width=15cm]{mfhi_wave.png}
                        \caption{A screenshot of the simulated waveforms for mfhi}
                    \end{center}
                \end{figure}

        \subsubsection{mflo R2}
            The LO register was preloaded to have a value of 10. As seen in T3, or when the signal Present\_state is equal to 4, the value stored in R2 is set to the value in LO. It should be noted that $10_{10}$ is equivalent to $a_{16}$. The control sequence for this instruction can be found in Appendix \ref{mflo_sequence}.
      
                \begin{figure}[h!]
                    \begin{center}
                        \includegraphics[width=15cm]{mflo_wave.png}
                        \caption{A screenshot of the simulated waveforms for mflo}
                    \end{center}
                \end{figure}

    \subsection{In and Out Instructions}
                
        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{in_wave_top_half.png}
                \caption{1st screenshot of the simulated waveforms for in, in R1}
            \end{center}
        \end{figure}

        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{in_wave_bottom_half.png}
                \caption{2nd screenshot of the simulated waveforms for in, in R1}
            \end{center}
        \end{figure}
        
        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{out_wave_top_half.png}
                \caption{1st screenshot of the simulated waveforms for out, out R1}
            \end{center}
        \end{figure}

        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{out_wave_bottom_half.png}
                \caption{2nd screenshot of the simulated waveforms out, out R1}
            \end{center}
        \end{figure}

    \subsection{Jump Instructions}
    The jump instruction functionality was simulated using the \emph{jal R1} and \emph{jr R1} commands. Thier control sequence was altered only for jal where Register 15 was enabled in the 3rd cycle.
      
        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{jal_wave.png}
                \caption{A screenshot of the simulated waveforms for jal, jal R1}
            \end{center}
        \end{figure}

        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=15cm]{jr_wave.png}
                \caption{A screenshot of the simulated waveforms for jr, jr R1}
            \end{center}
        \end{figure}


\appendix
\section{General Components}
    \lstinputlisting{datapath.v} \label{datapath.v}
    \lstinputlisting{Bus.v} \label{Bus.v}
    \lstinputlisting{register_zero.v} \label{register_zero.v}
\section{Select and Encode}
    \lstinputlisting{select_and_encode.v} \label{select_and_encode.v}
    \lstinputlisting{ComponentTestbenches/TB_select_and_encode.v} \label{TB_select_and_encode.v}
\section{Memory Subsystem}
    \lstinputlisting{ram.v} \label{ram.v}
    \lstinputlisting{MAR.v} \label{MAR.v}
    \lstinputlisting{MDR.v} \label{MDR.v}
\section{CON FF}
    \lstinputlisting{con_ff.v} \label{con_ff.v}
    \lstinputlisting{ALU.v} \label{ALU.v}
\section{Input/Output Ports}
    \lstinputlisting{inputPort.v} \label{inputPort.v}
    \lstinputlisting{outputPort.v} \label{outputPort.v}
    
\section{Control Sequences}
    \subsection{st \$90, R1} \label{st_case_1_sequence}
        \lstinputlisting{InstructionTestBenches/st_case_1_TB.v}
    \subsection{st \$90(R1), R1} \label{st_case_2_sequence}
        \lstinputlisting{InstructionTestBenches/st_case_2_TB.v}
    \subsection{ld R1, \$85), R1} \label{ld_case_1_sequence}
        \lstinputlisting{InstructionTestBenches/ld_case_1_TB.v}
    \subsection{ld R0, \$35(R1)} \label{ld_case_2_sequence}
        \lstinputlisting{InstructionTestBenches/ld_case_2_TB.v}
    \subsection{ldi R1, \$85} \label{ldi_case_3_sequence}
        \lstinputlisting{InstructionTestBenches/ldi_case_3_TB.v}
    \subsection{ldi R0, \$35(R1)} \label{ldi_case_4_sequence}
        \lstinputlisting{InstructionTestBenches/ldi_case_4_TB.v}
    \subsection{brzr R2, 35} \label{brzr_sequence}
        \lstinputlisting{InstructionTestBenches/brzr_TB.v}
    \subsection{brnz R2, 35} \label{brnz_sequence}
        \lstinputlisting{InstructionTestBenches/brnz_TB.v}
    \subsection{brpl R2, 35} \label{brpl_sequence}
        \lstinputlisting{InstructionTestBenches/brpl_TB.v}
    \subsection{brmi R2, 35} \label{brmi_sequence}
        \lstinputlisting{InstructionTestBenches/brmi_TB.v}
    \subsection{jal R1} \label{jal_sequence}
        \lstinputlisting{InstructionTestBenches/jal_TB.v}
    \subsection{jr R1} \label{jr_sequence}
        \lstinputlisting{InstructionTestBenches/jr_TB.v}
    \subsection{in R1} \label{in_sequence}
        \lstinputlisting{InstructionTestBenches/in_TB.v}
    \subsection{out R1} \label{out_sequence}
        \lstinputlisting{InstructionTestBenches/out_TB.v}
    \subsection{addi R2, R1, -5} \label{addi_sequence}
        \lstinputlisting{InstructionTestBenches/addi_TB.v}
    \subsection{andi R2, R1 \$26} \label{andi_sequence}
        \lstinputlisting{InstructionTestBenches/andi_TB.v}
    \subsection{ori R2, R1 \$26} \label{ori_sequence}
        \lstinputlisting{InstructionTestBenches/ori_TB.v}
    \subsection{mfhi R2} \label{mfhi_sequence}
        \lstinputlisting{InstructionTestBenches/mfhi_TB.v}
    \subsection{mflo R2} \label{mflo_sequence}
        \lstinputlisting{InstructionTestBenches/mflo_TB.v}
\section{RAM}
    \subsection{Initial Contents} \label{ram_init}
    \subsection{Post "st" instructions}
        \subsubsection{st \$90, R1} \label{ram_st_case_1}
            \lstinputlisting{memory_data/st_case_1_memdata.txt}
        \subsubsection{st \$90(R1), R1} \label{ram_st_case_2}
            \lstinputlisting{memory_data/st_case_2_memdata.txt}
    \subsection{Post "ld and ldi" instructions}
        \subsubsection{ld R1, \$85), R1} \label{ram_ld_case_1}
            \lstinputlisting{memory_data/ld_case_1.txt}
        \subsubsection{ld R0, \$35(R1)} \label{ram_ld_case_2}
            \lstinputlisting{memory_data/ld_case_2.txt}
        \subsubsection{ldi R1, \$85} \label{ram_ldi_case_3}
            \lstinputlisting{memory_data/ldi_case_3.txt}
        \subsubsection{ldi R0, \$35(R1)} \label{ram_ldi_case_4}
            \lstinputlisting{memory_data/ldi_case_4.txt}
    


\end{document}
