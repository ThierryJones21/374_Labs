\documentclass{article}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}

\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\lstset{
    language=Verilog,
    % wrap text
    breaklines=true, 
    % line numbers
    numbers=left,
    numberstyle=\tiny\color{black},
    numbersep=10pt,
    % other styling
    basicstyle=\small\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    tabsize=2
}
\graphicspath{ {Images/} }

\title{
    \begin{large}
        ELEC374 - Lab 3
    \end{large}
}
\author{Naod Dereje - 20103501, Thierry Jones - 20108349}

\begin{document}
\maketitle
\cleardoublepage
\tableofcontents
\cleardoublepage

\section{Components}
    The purpose of this lab was to design, simulate, implement and verify a simple RISC computer(Mini SRC), including the circuits associated with the logic behind: 
    Select and Encode, Memory Subsystem, CON FF and Input/Output ports. Verilog was chosen over VHDL as it is better for more complex simulations. The verilog code 
    for each of these components can be found in the Appendices.
    
    \subsection{Select and Encode}
    Select and Encode logic was used for load and store instruction as well as add, and, or instructions. The opcode that is read into Select and Encode is used to create the outputs for Ra, Rb , and Rc, in order to generate the GRa, GRb, GRc, which is the encoded to R0in-R15in and R0out-R15out registers. Their is also support for a sign-extended C value in the lower 19 bits of the instrcution address.

    \subsection{Memory Subsystem}
    The memory subsystem was created using the Megafunction in Quartus to generate inputs and outputs for the RAM accordingly. In order to define the memory subsystem within our project, an instance of the RAM was created on our datapath, and was wired to the datapath using existing wires created in the previous lab. The RAM's memory is accessed through the corresponding hex file in the project, Which contains the opcodes for the instructions at the specififed memory slots. A detailed breakdown of the memory subsystem can be found at Appendix \ref{ram.v}.

    \subsection{CON FF}
    The conff logic is created to ensure that conidtional logic such as the branch insturction are able to be executed. The instructions assocaited with the conditional logic are stored in I-formatting, with the second register holding the branching condition. The components for the con ff logic can be found at Appendix \ref{con_ff.v}.

    \subsection{Input/Output Ports}
    The input and output ports in the datapath allow for the bus to receive values from an input unit, as well as output values from the bus onto the output unit. In a real implmentation of an I/O port instruction, the logic for these ports would be used to read from some input given to port, and give feedback to the system through some output such as updating the result of an arithmetic instruction, or the bit pattern after a bit shift or rotation was completed. The code for the input and output ports can be found at Appendix \ref{inputPort.v} and Appendix \ref{outputPort.v} respectively.

\section{Circuitry Demonstration}
    To demonstrate the success of the RAM and memory interface logic, multiple testbenches were created to simulate each operation.  The testbenches all have their own control sequences unique to every operation and can be found in the appendices. The following subsections of the cicuitry demonstration will detail the changes made in the test benches due to the control sequence changing as well as the waveforms generated by each simulation. Each instruction used to demonstrate the circuitry requires a specific OP Code. The following table shows the OP Code values stored in RAM initially, their address in RAM and also the instruction itself. For a full version of the initial RAM state, please see Appendix \ref{ram_init}. Furthermore, in an effort to save paper, only the relevant signals were included for each instruction.
    \begin{figure}[h!] \label{relevant_ram_init}
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                Address (hex) & Instruction & Op code (hex) \\
                \hline
                28 & ld R1, 85 & 00800085 \\
                \hline
                29 & ld R1, \$35(R0) & 00800023 \\
                \hline
                30 & ldi R1,\$85 & 08800085 \\
                \hline
                31 & ldi R1, \$35(R0) & 08800023 \\
                \hline
                1* & st \$90, R1 & 10080090 \\ % Thierry, Naod, don't change this line, see below figure for rationale
                \hline
                1* & st \$90(R1), R1 & 10080090 \\ % Thierry, Naod, don't change this line, see below figure for rationale
                \hline
                8 & addi R2, R1, \$-5 & 590FFFFB \\
                \hline
                9 & andi R2, R1, \$26 & 61080026 \\
                \hline
                a & ori R2, R1, \$26 & 69080026 \\
                \hline
                30 & in R1  & A8800000 \\
                \hline
                31 & out R1  & B0800000 \\
                \hline
                20 & brzr R2, 35 & 91000023 \\
                \hline
                21 & brnz R2, 35 & 91200023 \\
                \hline
                22 & brpl R2, 35 & 91400023 \\
                \hline
                23 & brmi R2, 35 & 91600023 \\
                \hline
                18 & jal R1 & A0800000 \\                 
                \hline
                19 & jr R1 & 98800000 \\ 
                \hline
            \end{tabular}
            \caption{Table of relevant values in RAM initially}
        \end{center}
    \end{figure}
    \\
    \small{*Note that these instructions were tested before the rest, thus, the .hex file hadn't be completed. Thus, Appendix \ref{ram_st_case_1} and Appendix \ref{ram_st_case_2} have empty values in RAM where the OP Codes are for later tests.}

    \subsection{Load Instructions}
        Two load instructions were tested to ensure that the values are able to load from the RAM onto its appropriate register. The control sequences for \emph{ld R1,\$85}, \emph{ld R0, \$35(R1)}, \emph{ldi R1,\$85}, \emph{ldi R0, \$35(R1)} can be found in Appendices \ref{ld_case_1_sequence}, \ref{ld_case_2_sequence}, \ref{ldi_case_1_sequence}, and \ref{ldi_case_2_sequence} respectively. The value $85_{16}$ and $35_{16}$ was preloaded into the memory initialization file in slots $85_{16}$ and $35_{16}$ for these instructions respectively. The specific opcodes for these instructions can be found in Figure \ref{relevant_ram_init}, and the relevant address was loaded into the PC register. The value of $0_{16}$ was preloaded into register 1.
       
       

\cleardoublepage

\appendix
\section{General Components}
    \subsection{Control Unit} \label{control_unit.v}
        \lstinputlisting{control_unit.v}
    \subsection{Datapath} \label{datapath.v}
        \lstinputlisting{datapath.v}
    \subsection{Bus} \label{Bus.v}
        \lstinputlisting{Bus.v} 
    \subsection{Register Zero} \label{register_zero.v}
        \lstinputlisting{register_zero.v} 
    \subsection{Arithmetic Logic Unit} \label{ALU.v}
        \lstinputlisting{ALU.v}
\section{Select and Encode}
    \lstinputlisting{select_and_encode.v} \label{select_and_encode.v}
\section{Memory Subsystem}
    \subsection{RAM} \label{ram.v}
        \lstinputlisting{ram.v} 
    \subsection{Memory Address Register} \label{MAR.v}
        \lstinputlisting{MAR.v}
    \subsection{Memory Data Register} \label{MDR.v}
        \lstinputlisting{MDR.v} 
\section{CON FF} \label{con_ff.v}
    \lstinputlisting{con_ff.v} 
\section{Input/Output Ports}
    \subsection{Input Port} \label{inputPort.v}
        \lstinputlisting{inputPort.v}
    \subsection{Output Port} \label{outputPort.v}
        \lstinputlisting{outputPort.v}
    
\section{Control Sequences}
    \subsection{st \$90, R1} \label{st_case_1_sequence}
        \lstinputlisting{InstructionTestBenches/st_case_1_TB.v}
    \subsection{st \$90(R1), R1} \label{st_case_2_sequence}
        \lstinputlisting{InstructionTestBenches/st_case_2_TB.v}
    \subsection{ld R1, \$85), R1} \label{ld_case_1_sequence}
        \lstinputlisting{InstructionTestBenches/ld_case_1_TB.v}
    \subsection{ld R0, \$35(R1)} \label{ld_case_2_sequence}
        \lstinputlisting{InstructionTestBenches/ld_case_2_TB.v}
    \subsection{ldi R1, \$85} \label{ldi_case_1_sequence}
        \lstinputlisting{InstructionTestBenches/ldi_case_3_TB.v}
    \subsection{ldi R0, \$35(R1)} \label{ldi_case_2_sequence}
        \lstinputlisting{InstructionTestBenches/ldi_case_4_TB.v}
    \subsection{brzr R2, 35} \label{brzr_sequence}
        \lstinputlisting{InstructionTestBenches/brzr_TB.v}
    \subsection{brnz R2, 35} \label{brnz_sequence}
        \lstinputlisting{InstructionTestBenches/brnz_TB.v}
    \subsection{brpl R2, 35} \label{brpl_sequence}
        \lstinputlisting{InstructionTestBenches/brpl_TB.v}
    \subsection{brmi R2, 35} \label{brmi_sequence}
        \lstinputlisting{InstructionTestBenches/brmi_TB.v}
    \subsection{jal R1} \label{jal_sequence}
        \lstinputlisting{InstructionTestBenches/jal_TB.v}
    \subsection{jr R1} \label{jr_sequence}
        \lstinputlisting{InstructionTestBenches/jr_TB.v}
    \subsection{in R1} \label{in_sequence}
        \lstinputlisting{InstructionTestBenches/in_TB.v}
    \subsection{out R1} \label{out_sequence}
        \lstinputlisting{InstructionTestBenches/out_TB.v}
    \subsection{addi R2, R1, -5} \label{addi_sequence}
        \lstinputlisting{InstructionTestBenches/addi_TB.v}
    \subsection{andi R2, R1 \$26} \label{andi_sequence}
        \lstinputlisting{InstructionTestBenches/andi_TB.v}
    \subsection{ori R2, R1 \$26} \label{ori_sequence}
        \lstinputlisting{InstructionTestBenches/ori_TB.v}
    \subsection{mfhi R2} \label{mfhi_sequence}
        \lstinputlisting{InstructionTestBenches/mfhi_TB.v}
    \subsection{mflo R2} \label{mflo_sequence}
        \lstinputlisting{InstructionTestBenches/mflo_TB.v}

    


\end{document}
